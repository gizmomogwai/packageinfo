import std.stdio : stderr, writeln;
import std.process : execute;
import mir.deser.json : deserializeJson, serdeKeys, serdeIgnoreUnexpectedKeys;
import std.algorithm : find;
import std.range : appender;
import std.file : mkdirRecurse, write, append, exists, readText;
import std.conv : to;
import std.string : format;
import std.getopt : getopt, defaultGetoptPrinter;
import std.typecons : Tuple;

@serdeIgnoreUnexpectedKeys struct RootPackage
{
    Package[] packages;
}

@serdeIgnoreUnexpectedKeys struct Package
{
    string name;
    @serdeKeys("version")
    string semVer;
    string license;
    bool active;
}

void showVersion() {
    version (dogfood)
    {
        import asciitable;
        import packageinfo;
        import colored;
        import std.algorithm : sort, fold;
        // dfmt off
        stderr.writeln("Packageinfo:\n",
            packageinfo
                .packages
                .sort!("a.name < b.name")
                .fold!(
                    (table, p) =>
                        table
                            .row
                                .add(p.name.white)
                                .add(p.semVer.lightGray)
                                .add(p.license.lightGray)
                                .table)
                    (new AsciiTable(3)
                        .header
                            .add("Package".bold)
                            .add("Version".bold)
                            .add("License".bold)
                            .table)
             .format
                 .prefix("    ")
                 .headerSeparator(true)
                 .columnSeparator(true)
                 .to!string);
        // dfmt on
    }
}

void processDubOutput(T)(T output, string[] args) {
    auto result = appender!string;

    if (output.status == 0)
    {
        const outDir = "out/generated/packageinfo";
        outDir.mkdirRecurse;
        auto outFile = outDir ~ "/packageinfo.d";
        result.put("// DO NOT EDIT, GENERATED BY %s\n".format(args));
        result.put("module packageinfo;\n");
        result.put("struct PackageInfo\n{\n    string name;\n    string semVer;\n    string license;\n}\n");
        result.put("enum PackageInfo[] packages = [\n");
        auto rootPackage = deserializeJson!(RootPackage)(output.output.find("{"));
        foreach (p; rootPackage.packages)
        {
            if (p.active)
            {
                result.put("        PackageInfo(\"" ~ p.name ~ "\", \"" ~ p.semVer ~ "\", \"" ~ p.license ~ "\"),\n");
            }
        }
        result.put("    ];\n");
        if (outFile.exists) {
            const currentContent = outFile.readText;
            if (currentContent == result.data) {
                stderr.writeln("Packageinfo in %s is already up2date".format(outFile));
                return;
            }
        }
        write(outFile, result.data);
        stderr.writeln("Packageinfo has been written to %s".format(outFile));
    }
}

int main(string[] args)
{
    string config;

    {
        auto copy = args.dup;
        bool versionFlag = false;
        version (dogfood) {
            auto result = getopt(copy,
                                 "config|c", "Dub config (optional)", &config,
                                 "version|v", "Show version", &versionFlag,
            );
            if (versionFlag) {
                showVersion();
                return 0;
            }
        } else {
            auto result = getopt(copy,
                                 "config|c", "Dub config (optional)", &config,
            );
        }

        if (result.helpWanted) {
            defaultGetoptPrinter("packageinfo", result.options);
            return 0;
        }
    }

    auto command = appender!(string[]);
    command.put("dub");
    command.put("describe");
    if (config != null) {
        command.put("--config=%s".format(config));
    }
    auto output = command.data.execute;
    processDubOutput(output, args);
    return output.status;
}
