import mir.deser.json : deserializeJson, serdeIgnoreUnexpectedKeys, serdeKeys;
import std.algorithm : find;
import std.conv : to;
import std.file : append, exists, mkdirRecurse, readText, write;
import std.getopt : defaultGetoptPrinter, getopt;
import std.path : dirName;
import std.process : Config, execute, executeShell;
import std.range : appender;
import std.stdio : stderr, writeln;
import std.string : format;
import std.typecons : Tuple;

@serdeIgnoreUnexpectedKeys struct RootPackage
{
    Package[] packages;
}

@serdeIgnoreUnexpectedKeys struct Package
{
    string name;
    @serdeKeys("version")
    string semVer;
    string license;
    bool active;
}

void showVersion()
{
    version (dogfood)
    {
        import asciitable;
        import colored;
        import packageinfo;
        import std.algorithm : fold, sort;

        // dfmt off
        stderr.writeln("Packageinfo:\n",
            packageinfo
                .packages
                .sort!("a.name < b.name")
                .fold!(
                    (table, p) =>
                        table
                            .row
                                .add(p.name.white)
                                .add(p.semVer.lightGray)
                                .add(p.license.lightGray)
                                .table)
                    (new AsciiTable(3)
                        .header
                            .add("Package".bold)
                            .add("Version".bold)
                            .add("License".bold)
                            .table)
             .format
                 .prefix("    ")
                 .headerSeparator(true)
                 .columnSeparator(true)
                 .to!string);
        // dfmt on
    }
}

auto processDubOutput(T)(T output, string[] args)
{
    if (output.status != 0)
    {
        return output.status;
    }

    auto result = appender!string;
    const outDir = "out/generated/packageinfo";
    outDir.mkdirRecurse;
    auto outFile = outDir ~ "/packageinfo.d";
    result.put("// DO NOT EDIT, GENERATED BY %s\n".format(args));
    result.put("module packageinfo;\n");
    result.put(
        "struct PackageInfo\n{\n    string name;\n    string semVer;\n    string license;\n}\n");
    result.put("enum PackageInfo[] packages = [\n");
    auto rootPackage = deserializeJson!(RootPackage)(output.output);
    foreach (p; rootPackage.packages)
    {
        if (p.active)
        {
            // dfmt off
            result.put("        PackageInfo(\"" ~ p.name ~ "\", \"" ~ p.semVer ~ "\", \"" ~ p.license ~ "\"),\n");
            // dfmt on
        }
    }
    result.put("    ];\n");
    if (outFile.exists)
    {
        const currentContent = outFile.readText;
        if (currentContent == result.data)
        {
            stderr.writeln("Packageinfo in %s is already up2date".format(outFile));
            return 0;
        }
    }
    write(outFile, result.data);
    stderr.writeln("Packageinfo has been written to %s".format(outFile));
    return 0;
}

int main(string[] args)
{
    string config;

    {
        auto copy = args.dup;
        bool versionFlag = false;
        version (dogfood)
        {
            // dfmt off
            auto result = getopt(copy,
                "config|c", "Dub config (optional)", &config,
                "version|v", "Show version", &versionFlag,
            );
            // dfmt on
            if (versionFlag)
            {
                showVersion();
                return 0;
            }
        }
        else
        {
            auto result = getopt(copy, "config|c", "Dub config (optional)", &config,);
        }

        if (result.helpWanted)
        {
            defaultGetoptPrinter("packageinfo", result.options);
            return 0;
        }
    }

    auto command = appender!(string[]);
    command.put("which $DC".executeShell.output.dirName ~ "/dub");
    command.put("describe");
    if (config != null)
    {
        command.put("--config=%s".format(config));
    }
    return command.data.execute(config: Config.stderrPassThrough).processDubOutput(args);
}
